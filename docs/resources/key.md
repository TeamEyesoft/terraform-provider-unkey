---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "unkey_key Resource - unkey"
subcategory: ""
description: |-
  Create a new API key for user authentication and authorization.
  Use this endpoint when users sign up, upgrade subscription tiers, or need additional keys. Keys are cryptographically secure and unique to the specified API namespace.
  Important: The key is returned only once. Store it immediately and provide it to your user, as it cannot be retrieved later.
  Common use cases:
  Generate keys for new user registrationsCreate additional keys for different applicationsIssue keys with specific permissions or limits
  Required Permissions
  Your root key needs one of:
  api.*.create_key (create keys in any API)api.<api_id>.create_key (create keys in specific API)
---

# unkey_key (Resource)

Create a new API key for user authentication and authorization.

Use this endpoint when users sign up, upgrade subscription tiers, or need additional keys. Keys are cryptographically secure and unique to the specified API namespace.

Important: The key is returned only once. Store it immediately and provide it to your user, as it cannot be retrieved later.

## Common use cases:

- Generate keys for new user registrations
- Create additional keys for different applications
- Issue keys with specific permissions or limits

## Required Permissions

Your root key needs one of:

- api.*.create_key (create keys in any API)
- api.<api_id>.create_key (create keys in specific API)



<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `api_id` (String) The API namespace this key belongs to.
Keys from different APIs cannot access each other.
- `byte_length` (Number) Controls the cryptographic strength of the generated key in bytes.
Higher values increase security but result in longer keys that may be more annoying to handle.
The default 16 bytes provides 2^128 possible combinations, sufficient for most applications.
Consider 32 bytes for highly sensitive APIs, but avoid values above 64 bytes unless specifically required.

### Optional

- `credits` (Attributes) Controls usage-based limits through credit consumption with optional automatic refills.
Unlike rate limits which control frequency, credits control total usage with global consistency.
Essential for implementing usage-based pricing, subscription tiers, and hard usage quotas.
Omitting this field creates unlimited usage, while setting null is not allowed during creation. (see [below for nested schema](#nestedatt--credits))
- `enabled` (Boolean) Controls whether the key is active immediately upon creation.
When set to 'false', the key exists but all verification attempts fail with 'code=DISABLED'.
Useful for pre-creating keys that will be activated later or for keys requiring manual approval.
Most keys should be created with 'enabled=true' for immediate use.
- `expires` (Number) Sets when this key automatically expires as a Unix timestamp in milliseconds.
Verification fails with code=EXPIRED immediately after this time passes.
Omitting this field creates a permanent key that never expires.

Avoid setting timestamps in the past as they immediately invalidate the key.
Keys expire based on server time, not client time, which prevents timezone-related issues.
Essential for trial periods, temporary access, and security compliance requiring key rotation.
- `external_id` (String) Links this key to a user or entity in your system using your own identifier.
Returned during verification to identify the key owner without additional database lookups.
Essential for user-specific analytics, billing, and multi-tenant key management.
Use your primary user ID, organization ID, or tenant ID for best results.
Accepts letters, numbers, underscores, dots, and hyphens for flexible identifier formats.
- `meta` (String) Links this key to a user or entity in your system using your own identifier.
Returned during verification to identify the key owner without additional database lookups.
Essential for user-specific analytics, billing, and multi-tenant key management.
Use your primary user ID, organization ID, or tenant ID for best results.
Accepts letters, numbers, underscores, dots, and hyphens for flexible identifier formats.
- `name` (String) Sets a human-readable identifier for internal organization and dashboard display.
Never exposed to end users, only visible in management interfaces and API responses.
Avoid generic names like "API Key" when managing multiple keys for the same user or service.
- `permanent_deletion` (Boolean) Controls deletion behavior between recoverable soft-deletion and irreversible permanent erasure.
Soft deletion (default) preserves key data for potential recovery through direct database operations.
Permanent deletion completely removes all traces including hash values and metadata with no recovery option.

Use permanent deletion only for regulatory compliance (GDPR), resolving hash collisions, or when reusing identical key strings.
Permanent deletion cannot be undone and may affect analytics data that references the deleted key.
Most applications should use soft deletion to maintain audit trails and prevent accidental data loss.
- `permissions` (List of String) Grants specific permissions directly to this key without requiring role membership.
Wildcard permissions like 'documents.*' grant access to all sub-permissions including 'documents.read' and 'documents.write'.
Direct permissions supplement any permissions inherited from assigned roles.
- `prefix` (String) Adds a visual identifier to the beginning of the generated key for easier recognition in logs and dashboards.
The prefix becomes part of the actual key string (e.g., prod_xxxxxxxxx).
Avoid using sensitive information in prefixes as they may appear in logs and error messages.
- `ratelimits` (Attributes List) Defines time-based rate limits that protect against abuse by controlling request frequency.
Unlike credits which track total usage, rate limits reset automatically after each window expires.
Multiple rate limits can control different operation types with separate thresholds and windows.
Essential for preventing API abuse while maintaining good performance for legitimate usage. (see [below for nested schema](#nestedatt--ratelimits))
- `recoverable` (Boolean) Controls whether the plaintext key is stored in an encrypted vault for later retrieval.
When true, allows recovering the actual key value using keys.getKey with decrypt=true.
When false, the key value cannot be retrieved after creation for maximum security.
Only enable for development keys or when key recovery is absolutely necessary.
- `roles` (List of String) Assigns existing roles to this key for permission management through role-based access control.
Roles must already exist in your workspace before assignment.
During verification, all permissions from assigned roles are checked against requested permissions.
Roles provide a convenient way to group permissions and apply consistent access patterns across multiple keys.

### Read-Only

- `id` (String) The unique identifier for this key in Unkey's system.
This is NOT the actual API key, but a reference ID used for management operations like updating or deleting the key.
Store this ID in your database to reference the key later. This ID is not sensitive and can be logged or displayed in dashboards.
- `key` (String, Sensitive) The full generated API key that should be securely provided to your user.
SECURITY WARNING: This is the only time you'll receive the complete key - Unkey only stores a securely hashed version. Never log or store this value in your own systems; provide it directly to your end user via secure channels. After this API call completes, this value cannot be retrieved again (unless created with recoverable=true).
- `last_updated` (String) Timestamp of the last Terraform update of the API.

<a id="nestedatt--credits"></a>
### Nested Schema for `credits`

Required:

- `remaining` (Number) Number of credits remaining (null for unlimited).

Optional:

- `refill` (Attributes) Configuration for automatic credit refill behavior. (see [below for nested schema](#nestedatt--credits--refill))

<a id="nestedatt--credits--refill"></a>
### Nested Schema for `credits.refill`

Required:

- `amount` (Number) Number of credits to add during each refill cycle.
- `interval` (String) How often credits are automatically refilled.

Optional:

- `refill_day` (Number) Day of the month for monthly refills (1-31).
Only required when interval is 'monthly'.
For days beyond the month's length, refill occurs on the last day of the month.



<a id="nestedatt--ratelimits"></a>
### Nested Schema for `ratelimits`

Required:

- `auto_apply` (Boolean) Whether this ratelimit should be automatically applied when verifying a key.
- `duration` (Number) The duration for each ratelimit window in milliseconds.

This controls how long the rate limit counter accumulates before resetting. Common values include:

- 1000 (1 second): For strict per-second limits on high-frequency operations
- 60000 (1 minute): For moderate API usage control
- 3600000 (1 hour): For less frequent but costly operations
- 86400000 (24 hours): For daily quotas

Shorter windows provide more frequent resets but may allow large burst usage. Longer windows provide more consistent usage patterns but take longer to reset after limit exhaustion.
- `limit` (Number) The maximum number of operations allowed within the specified time window.

When this limit is reached, verification requests will fail with code=RATE_LIMITED until the window resets. The limit should reflect:

- Your infrastructure capacity and scaling limitations
- Fair usage expectations for your service
- Different tier levels for various user types
- The relative cost of the operations being limited

Higher values allow more frequent access but may impact service performance.
- `name` (String) The name of this rate limit. This name is used to identify which limit to check during key verification.

Best practices for limit names:

- Use descriptive, semantic names like 'api_requests', 'heavy_operations', or 'downloads'
- Be consistent with naming conventions across your application
- Create separate limits for different resource types or operation costs
- Consider using namespaced names for better organization (e.g., 'files.downloads', 'compute.training')

You will reference this exact name when verifying keys to check against this specific limit.
